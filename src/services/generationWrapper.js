import { preLogUsage, refundUsage, postLogUsage } from './logUsage.js'
import { freeTierLimiter } from '../middleware/freeTierLimiter.js'
import { imageModels } from '../shared/imageModels/index.js'
import { videoModels } from '../shared/videoModels/index.js'
import { selectProvider } from '../utils/providerSelector.js'
import util from 'util'

// Errors that trigger a switch to a secondary provider if available
const PROVIDER_SWITCH_ERRORS = [
  'insufficient_quota',
  'usage_limit_exceeded',
  'rate_limit_exceeded',
  '429',
  'credit',
  'balance',
  'quota',
  'too many requests',
  'This API method requires billing to be enabled',
  'Invalid API key',
  'The model is overloaded. Please try again later.',
]

function isProviderSwitchError(error) {
  const errorMessage = (error?.errorResponse?.error?.message || error?.message || '').toLowerCase()
  if (!errorMessage) return false
  return PROVIDER_SWITCH_ERRORS.some(msg => errorMessage.includes(msg.toLowerCase()))
}

// Errors that trigger a single retry attempt
const RETRYABLE_ERRORS = [
  'Unknown error while reading results. Please try again later or contact support at support@runware.ai',
  'online_prediction_requests_per_base_model',
  'Infrastructure is at maximum capacity, try again later',
  'An unknown error occurred',
  'No image or text found in response',
  'No image generated by Gemini.',
  "Invalid content detected. The generated content was flagged and rejected by Google's content moderation system.",
  'Unknown error while reading results. Please try again later.',
  'unknown error',
  'An unknown error occurred',
  `... is not valid JSON`,
  `Deadline expired before operation could complete`,
  `Processing (Stuck?)`,
  `Internal error encountered.`,
  `ByteDance responded with an error. The provider returned the . Additional information below.`, // usually server overload
  'The provider "Google" returned an invalid response. Additional information: No content data returned from Google',
  'High concurrency usage of this API, please reduce concurrency or contact customer service to increase limits',
  'An error has occurred please read documentation for additional details.',
  'The operation was cancelled.',
  'ECONNRESET',
  '504 Gateway Time-out',
  'Inference error occurred while processing the request. Please try again or contact support if the issue persists.',
]

function isRetryableError(error) {
  const errorMessage = (error?.errorResponse?.error?.message || error?.message || '').toLowerCase()
  if (!errorMessage) return false
  return RETRYABLE_ERRORS.some(retryMsg => errorMessage.includes(retryMsg.toLowerCase()))
}

function cleanupInternalFields(result) {
  if (result && result.data && Array.isArray(result.data)) {
    result.data.forEach(item => {
      delete item._uploadedUrl
      delete item.original_response_from_provider
    })
  }
  
  // Also remove from top-level result
  if (result) {
    delete result.original_response_from_provider
  }
}

export function createGenerationHandler({ validateParams, generateFn }) {
  return async function generationHandler(req, res) {
    try {
      const apiKey = res.locals.key
      const params = validateParams(req)

      try {
        // Run daily free-tier check
        await freeTierLimiter(req, res, () => {})
        if (res.headersSent) {
          // freeTierLimiter already responded (limit exceeded or error)
          return
        }

        // Select provider once per request to keep consistency across logging and generation
        const models = { ...imageModels, ...videoModels }
        const modelConfig = models[params.model]
        const providerIndex = selectProvider(modelConfig?.providers, params)

        const usageLogEntry = await preLogUsage(params, apiKey, req, providerIndex)

        let generationResult
        let retryErrors = [] // Collect original responses from any failures
        let activeProviderIndex = providerIndex
        
        try {
          const fetchParams = structuredClone(params) // prevent side effects
          
          try {
            generationResult = await generateFn(fetchParams, apiKey.user.id, res, usageLogEntry.id, activeProviderIndex)
          } catch (error) {
            // Check for provider switch errors first
            if (isProviderSwitchError(error) && modelConfig?.providers?.length > 1) {
              // Capture original response
              const originalResponse = error?.errorResponse?.original_response_from_provider
              if (originalResponse) {
                retryErrors.push(originalResponse)
              }

              const errorMessage = error?.errorResponse?.error?.message || error?.message
              const nextProviderIndex = (activeProviderIndex + 1) % modelConfig.providers.length
              console.log(`Switching provider from ${modelConfig.providers[activeProviderIndex].id} to ${modelConfig.providers[nextProviderIndex].id} due to error: ${errorMessage}`)
              
              // Switch to the next provider
              activeProviderIndex = nextProviderIndex
              
              const retryParams = structuredClone(params)
              generationResult = await generateFn(retryParams, apiKey.user.id, res, usageLogEntry.id, activeProviderIndex)

            } else if (isRetryableError(error)) {
              // Capture the original response from the first failure
              const originalResponse = error?.errorResponse?.original_response_from_provider
              if (originalResponse) {
                retryErrors.push(originalResponse)
              }
              const errorMessage = error?.errorResponse?.error?.message || error?.message
              console.log(`Retrying generation due to error: ${errorMessage}`)
              const retryParams = structuredClone(params)
              if (errorMessage
                && (errorMessage.includes('No image or text found in response')
                  || errorMessage.includes('No image generated by Gemini.')
                  || errorMessage.includes("Invalid content detected. The generated content was flagged and rejected by Google's content moderation system.")
                )
              ) {
                retryParams.prompt += "\nIMPORTANT: Generate an image and don't include any text."
              }

              generationResult = await generateFn(retryParams, apiKey.user.id, res, usageLogEntry.id, activeProviderIndex)
            } else {
              throw error
            }
          }

        } catch (error) {
          // Final failure - capture original response
          const originalResponse = error?.errorResponse?.original_response_from_provider
          if (originalResponse) {
            retryErrors.push(originalResponse)
          }
          
          const errorToLog = error?.errorResponse?.error?.message || error?.message || 'unknown error'
          await refundUsage(apiKey, usageLogEntry, errorToLog, retryErrors.length > 0 ? retryErrors : null)
          throw error
        }

        const postPriceInt = await postLogUsage(params, apiKey, usageLogEntry, generationResult, activeProviderIndex, retryErrors.length > 0 ? retryErrors : null)
        generationResult.cost = postPriceInt / 10000

        cleanupInternalFields(generationResult)

        res.write(JSON.stringify(generationResult))
        res.end()
      } catch (error) {
        console.error('generationHandler error:')
        console.error(util.inspect(error, { depth: null, colors: false, maxArrayLength: null }))
        // If the error is already in the correct format, forward it as-is
        if (error?.errorResponse) {
          delete error.errorResponse.original_response_from_provider
          res.write(JSON.stringify(error.errorResponse))
          res.status(error.status || 500).end()
          return
        }

        const errorResponse = {
          error: {
            message: error.message || 'Failed to generate',
            type: 'internal_error'
          }
        }
        res.write(JSON.stringify(errorResponse))
        res.status(500).end()
      }
    } catch (error) {
      console.error('Generation error:')
      console.error(util.inspect(error, { depth: null, colors: false, maxArrayLength: null }))
      res.status(400)
      res.write(JSON.stringify({
        error: {
          message: error.message || 'Failed to generate',
          type: 'invalid_request_error'
        }
      }))
      res.end()
    }
  }
} 